#!/usr/bin/perl -w


#get rid of %rhelsub


# CHANGE LOG
# ----------
#  2021-05-30	njeffrey	Script created
#  2021-07-26	njeffrey	Update get_subscription_status subroutine to detect "Not Subscribed"
#  2021-11-23	njeffrey	Confirm perimeter firewall allows connectivity to https://subscription.rhsm.redhat.com
#



# nagios check to verify Red Hat Enterprise Linux subscription status
#
# The subscription-manager command requires root priviles to run, 
# so run this script daily from the root crontab to generate a file the nagios check can read


# CONFIGURATION
# -------------
#  Create a crontab entry for the root user similar to:
#  59 11,23 * * * /usr/local/nagios/libexec/check_rhel_subscription   #nagios helper script
#
#  This script is executed remotely on a monitored system by the NRPE or check_by_ssh
#  methods available in nagios.  
#
#  If you hare using the check_by_ssh method, you will need a section in the services.cfg
#  file on the nagios server that looks similar to the following.
#  This assumes that you already have ssh key pairs configured.
#  # Define service for checking time synchronization 
#  define service{
#     use                             generic-service
#     hostgroup_name                  all_rhel
#     service_description             RHEL subscription
#     check_interval                  7200     ; only check every 12 hours
#     check_command                   check_by_ssh!/usr/local/nagios/libexec/check_rhel_subscription
#     }
#
#  Alternatively, if you are using the NRPE method, you should have a section similar to the following in 
#  the services.cfg file:
#  define service{
#     use                             generic-service
#     hostgroup_name                  all_rhel
#     service_description             RHEL subscription
#     check_command                   check_nrpe!check_rhel_subscription
#     normal_check_interval           7200     ; only check every 12 hours
#     }
#
#  If you are using the NRPE method, you will also need a command definition similar to the following on each monitored host
#  in the /usr/local/nagios/nrpe/nrpe.cfg file:
#      command[check_rhel_subscription]=/usr/local/nagios/libexec/check_rhel_subscription




# TROUBLESHOOTING
# ---------------
#
#   This script requires root privileges to run the subscription-manager command
#
#   Rather than give the nagios user and additional privileges, this script will run from the root crontab every 12 hours,
#   generating a /tmp/nagios.check_rhel_subscription.tmp file.  This file will be read by the low-privileged nagios user
#   when the check is run from nagios.
#   Ensure the root crontab has an entry similar to the following:
#   59 11,23 * * * /usr/local/nagios/libexec/check_rhel_subscription   #nagios helper script




use strict;						#enforce good coding practices
use Getopt::Long;                       		#allow --long-switches to be used as parameters
use Time::Local;					#perform date/time calculations   yum install perl-Time-Local


# Declare variables
my ($product_id,$days_warn,$days_crit,$subscriptionmanager,$nmap,$cmd,%rhelsub);
my ($sec, $min, $hour, $mday, $mon, $year);
my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks);
my ($epoch_seconds_timestamp,$epoch_seconds_now);
my ($output_filename,$output_file_age,$output_message,$common_output_data,$perf_data,$verbose,$datecalc);
my ($opt_h,$opt_v,$opt_w,$opt_c);
my ($OK,$WARN,$CRITICAL,$UNKNOWN,$CHECK_NAME);
$product_id = 479;						# Product ID 479 is RHEL
$days_warn  = 30;						# default value, can be overridden with --warn=#
$days_crit  = 15;						# default value, can be overridden with --crit=#
$subscriptionmanager = "/usr/bin/subscription-manager";		#location of binary
$nmap = "/usr/bin/nmap";					#location of binary
$verbose = "no";						#yes|no flag to increase verbosity for debugging
$CHECK_NAME = "RHEL subscription";
#
# Nagios return codes
#
$OK=		0;
$WARN=		1;
$CRITICAL=	2;
$UNKNOWN=	3;





sub get_options {
   #
   # this gets the command line parameters provided by the users
   #
   print "Running get_options subroutine \n" if ($verbose eq "yes");
   Getopt::Long::Configure('bundling');
   GetOptions(
      "h"   => \$opt_h, "help"    => \$opt_h,
      "v"   => \$opt_v, "verbose" => \$opt_v,
      "w=i" => \$opt_w, "warn=i"  => \$opt_w,  "warning=i"  => \$opt_w,
      "c=i" => \$opt_c, "crit=i"  => \$opt_c,  "critical=i" => \$opt_c,
   );
   #
   # If the user supplied the -h or --help switch, give them some help.
   #
   if( defined( $opt_h ) ) {
      print "Use this syntax \n";
      print "   $0 \n";
      print "   $0 --verbose     (increase output for debugging \n";
      print "   $0 --warn=#      (# of days to warn     before subscription expiry \n";
      print "   $0 --crit=#      (# of days to critical before subscription expiry \n";
      exit $CRITICAL;				#exit script
   }
   #
   # If the user supplied the --verbose switch, increase output verbosity
   #
   if( defined( $opt_v ) ) {
      $verbose = "yes";
   } else {
      $verbose = "no";
   }
   #
   # If the user provided -w or --warn or --warning parameter, use that value as the number of days to warn on
   #
   if( defined( $opt_w ) ) {
      $days_warn = $opt_w;
      print "   setting warning threshold to $days_warn days \n" if ($verbose eq "yes");
   }
   #
   # If the user provided -c or --crit or --critical parameter, use that value as the number of days to warn on
   #
   if( defined( $opt_c ) ) {
      $days_crit = $opt_c;
      print "   setting critical threshold to $days_crit days \n" if ($verbose eq "yes");
   }

}                       #end of subroutine





sub sanity_checks {
   #
   print "Running sanity_checks subroutine \n" if ($verbose eq "yes");
   #
   # confirm /usr/sbin/subscription-manager file exists 
   if ( ! -e $subscriptionmanager ) {
      print "ERROR: Cannot find $subscriptionmanager \n";
      exit $CRITICAL;
   }
   #
   # confirm /usr/sbin/subscription-manager file exists 
   if ( ! -e $subscriptionmanager ) {
      print "ERROR: Cannot find $subscriptionmanager \n";
      exit $CRITICAL;
   }
}						#end of subroutine








sub check_for_output_file {
   #
   # a cron job may have already created the output file that we need
   #
   print "running check_for_output_file subroutine \n" if ($verbose eq "yes");
   #
   $output_filename = "/tmp/nagios.check_rhel_subscription.tmp";
   #
   # delete the output file if it is more than 24 hours (86400 seconds) old (this will work when run via root user but not when run as nagios user due to permissions)
   if ( -e "$output_filename" )  {             				#see if a cron job has already provided the info we need
      ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($output_filename); #get last modification time in seconds since the epoch
      $output_file_age = time - $mtime;                                 #figure out how many seconds old the file is
      print "   output file $output_filename is $output_file_age seconds old \n" if ($verbose eq "yes");
      if ( $output_file_age >= 86400 ) {                                  #see if the file is more than 240 seconds old
         if ( -w $output_filename )  {             			#file is writable if this script executed by root, but read-only when executed via nagios	
            print "   deleting old copy of $output_filename \n" if ($verbose eq "yes");
            unlink "$output_filename";                                  #delete the file if it is too old
         }
      }
      if ( (-e "$output_filename") && ($output_file_age >= 86400) ) {        #raise an alert if the file is more than 86400 seconds old
         print "$CHECK_NAME WARN - temporary file $output_filename not being automatically created via cron.  Please investigate. \n";
         exit $WARN;                                                    #exit script
      }									#end of if block
   }                                                                    #end of if block
   #
   if ( -e "$output_filename" ) {   		            		#see if a cron job has already provided the info we need
      open (OUT,"$output_filename") or die "Cannot open $output_filename for reading $! \n";
      while (<OUT>) {                                                   #read a line from the text file
         $output_message = $_  if ( $_ =~ /[a-zA-Z]/);                  #get the content of the output file into a variable
         print "   output message is $output_message \n" if ($verbose eq "yes");
      }                                                                 #end of while loop
      close OUT;                                                        #close filehandle
      print $output_message;                                            #print the content of the output file
      exit $CRITICAL if ( $output_message =~ /CRITICAL/ );              #exit script with appropriate return code
      exit $WARN     if ( $output_message =~ /WARN/ );                  #exit script with appropriate return code
      exit $UNKNOWN  if ( $output_message =~ /UNKNOWN/ );               #exit script with appropriate return code
      exit $OK       if ( $output_message =~ /OK/ );                    #exit script with appropriate return code
   }                                                                    #end of if block
}                                                                       #end of subroutine





sub print_to_outputfile {
   #
   print "running print_to_outputfile \n" if ($verbose eq "yes");
   #
   # This subroutine is called whenever an output message is printed, to confirm that the $output_file exists
   #
   # confirm the output message exists
   $output_message = "$CHECK_NAME UNKNOWN - could not parse response from remote host \n" unless ($output_message);
   #
   # confirm the $output_filename variable is defined
   unless ($output_filename) {
      print "$CHECK_NAME UNKNOWN - the \$output_filename variable is not defined.  This might be a script bug. \n";
      exit $UNKNOWN;                                                            #only get this far if OK/WARN/CRITICAL/UNKNOWN was not found in the output file
   }                                                                            #end of unless block
   #
   if ( ! -e "$output_filename" ) {                                                     #only run this section if $output_filename does not already exist
      print "   $output_filename not found - writing output message to $output_filename \n" if ($verbose eq "yes");
      open (OUT,">$output_filename") or die "Cannot open $output_filename for writing: $! \n";
      print OUT "$output_message";
      close OUT;                                                                #close filehandle
      chmod 0644, "$output_filename";                                           #set the file permission to -rw-r--r-- to ensure nagios user can read file
   }                                                                            #end of if block
}                                                                               #end of subroutine



sub check_internet_access {
   #
   print "Running check_internet_access subroutine \n" if ($verbose eq "yes");
   #
   #
   #
   # confirm connectivity to https://subscription.rhsm.redhat.com:443
   # Successful connection should look similar to:
   #    $ nmap -Pn -p 443 subscription.rhsm.redhat.com
   #    Starting Nmap 6.40 ( http://nmap.org ) at 2021-11-23 13:56 MST
   #    Nmap scan report for subscription.rhsm.redhat.com (209.132.183.108)
   #    Host is up (0.074s latency).
   #    PORT    STATE SERVICE
   #    443/tcp open  https      <--- state should be "open".  If "filtered" or "closed", perimeter firewall may be blocking
   #    Nmap done: 1 IP address (1 host up) scanned in 0.11 seconds
   # If name resolution is broken, output will look similar to:
   #    $ nmap -Pn -p 443 subscription.rhsm.redhat.com
   #    Failed to resolve "subscription.rhsm.redhat.com".
   #    WARNING: No targets were specified, so 0 hosts scanned.
   #    Nmap done: 0 IP addresses (0 hosts up) scanned in 0.09 seconds
   #
   #
   $rhelsub{internet_access} = "unknown";			#initialize hash element
   $cmd = "$nmap -Pn -p 443 subscription.rhsm.redhat.com";  
   print "   running command: $cmd \n" if ($verbose eq "yes");
   open (IN,"$cmd 2>&1|");	#open filehandle
   while (<IN>) {						#read a line from the filehandle
      if ( /Failed to resolve/ ) {				#broken name resolution
         $rhelsub{internet_access} = "BadNameResolution";
      }
      if ( /^443\/tcp open/ ) {					#state will be "open" if we have working connectivity
         $rhelsub{internet_access} = "open";
      }
      if ( /^443\/tcp filtered/ ) {				#state will be "filtered" if blocked by firewall
         $rhelsub{internet_access} = "filtered";
      }
      if ( /^443\/tcp closed/ ) {				#state will be "closed if remote host does not respond
         $rhelsub{internet_access} = "closed";
      }
   }								#end of while loop
   close IN;							#close filehandle
}								#end of subroutine



sub get_subscription_status {
   #
   print "running get_subscription_status subroutine \n" if ($verbose eq "yes");
   #
   # Output of command will be similar to the following for a machine with a valid subscription:
   #  /usr/sbin/subscription-manager list --matches=479
   #  +-------------------------------------------+
   #    Installed Product Status
   #  +-------------------------------------------+
   #  Product Name:   Red Hat Enterprise Linux for x86_64
   #  Product ID:     479
   #  Version:        8.4
   #  Arch:           x86_64
   #  Status:         Subscribed
   #  Status Details:
   #  Starts:         06/30/2020
   #  Ends:           06/30/2021
   #
   #
   # Output of command will be similar to the following for a machine without a valid subscription:
   # +-------------------------------------------+
   # Installed Product Status
   # +-------------------------------------------+
   # Product Name:   Red Hat Enterprise Linux for x86_64
   # Product ID:     479
   # Version:        8.4
   # Arch:           x86_64
   # Status:         Not Subscribed
   # Status Details: Not supported by a valid subscription.
   # Starts:
   # Ends:
   #
   $rhelsub{Status} = "unknown";				#initialize hash element to avoid undef errors
   #
   return unless ($rhelsub{internet_access} eq "open");		#break out of this subroutine if we do not have internet access
   #
   $cmd = "$subscriptionmanager list --matches=$product_id";  
   print "   running command: $cmd \n" if ($verbose eq "yes");
   open (IN,"$cmd 2>&1|");	#open filehandle
   while (<IN>) {						#read a line from the filehandle
      if ( /Status: +([a-zA-Z0-9 ]+)/ ) {
         $rhelsub{Status} = $1;					#assign value to hash
      }
      if ( /Ends: +([0-9]{2})\/([0-9]{2})\/([0-9]{4})/ ) {	#look for local-dependent mm/dd/yyyy format
         $mon   = $1;						#assign value to variable
         $mday  = $2;						#assign value to variable
         $year  = $3;						#assign value to variable
         $rhelsub{Ends} = "$mon\/$mday\/$year";			#put mm/dd/yyyy into hash as human readable output
      }
      if ( /Ends: +([0-9]{4})\-([0-9]{2})\-([0-9]{2})/ ) {	#look for locale-dependent yyyy-mm-dd format
         $mon   = $2;						#assign value to variable
         $mday  = $3;						#assign value to variable
         $year  = $1;						#assign value to variable
         $rhelsub{Ends} = "$year-$mon\/$mday";			#put yyy-mm-dd into hash as human readable output
      }
   }								#end of while loop
   close IN;							#close filehandle
   #
   # 
   if ( $rhelsub{Status} eq "Subscribed" ) {
      # figure out how many days until subscription expires
      # convert the yyyy-mm-dd date in the subscription expiry to seconds since the epoch  (decrement $mon by 1 and decrement $year by 1900)
      $sec=0; $min=0; $hour=0;	#ignore seconds/minutes/hours, granularity to a single day is fine
      $epoch_seconds_timestamp = timelocal( $sec, $min, $hour, $mday, $mon-1, $year-1900);		#use Time::Local module to convert yyyy-mm-dd hh:mm:ss to epoch
      $epoch_seconds_now = time;								#seconds since epoch
      print "current seconds since epoch is $epoch_seconds_now \n" if ($verbose eq "yes");
      print "subscription expiry is $year-$mon-$mday $hour:$min:$sec is $epoch_seconds_timestamp seconds since epoch \n" if ($verbose eq "yes");
      $datecalc =  $epoch_seconds_timestamp-$epoch_seconds_now ;
      print "epoch_seconds_timestamp-epoch_seconds_now = $epoch_seconds_timestamp-$epoch_seconds_now = $datecalc seconds from now \n" if ($verbose eq "yes");
      $datecalc = $datecalc / 86400;				#convert seconds to days
      $datecalc = sprintf("%.0f",$datecalc);			#truncate to 0 decimal places, closest day is good enough
      print "Subscription expires in $datecalc days \n" if ($verbose eq "yes");
   }								#end of if block
}                                               		#end of subroutine








sub print_output {
   #
   print "Running print_output subroutine \n" if ($verbose eq "yes");
   #
   $common_output_data = "";
   $perf_data = "";
   #
   #
   if ( $rhelsub{internet_access} eq "unknown" ) {
      $output_message = "$CHECK_NAME UNKNOWN - could not determine if internet access was available.  Please troubleshoot with: nmap -Pn -p 443 subscription.rhm.redhat.com  $common_output_data | $perf_data \n";
      print_to_outputfile;           				#call subroutine to confirm the output is in the $output_filename used for subsequent script runs
      print $output_message;
      exit $UNKNOWN;
   }
   if ( $rhelsub{internet_access} eq "BadNameResolution" ) {
      $output_message = "$CHECK_NAME UNKNOWN - Cannot resolve hostname subscription.rhsm.redhat.com.  Please check DNS to confirm working name resolution.  $common_output_data | $perf_data \n";
      print_to_outputfile;           				#call subroutine to confirm the output is in the $output_filename used for subsequent script runs
      print $output_message;
      exit $UNKNOWN;
   }
   if ( $rhelsub{internet_access} eq "filtered" ) {
      $output_message = "$CHECK_NAME UNKNOWN - Cannot connect to https://subscription.rhsm.redhat.com:443 to verify RHEL subscription status.  Please confirm perimeter firewall allows this outgoing connection.  $common_output_data | $perf_data \n";
      print_to_outputfile;           				#call subroutine to confirm the output is in the $output_filename used for subsequent script runs
      print $output_message;
      exit $UNKNOWN;
   }
   if ( $rhelsub{internet_access} eq "closed" ) {
      $output_message = "$CHECK_NAME UNKNOWN - Cannot connect to https://subscription.rhsm.redhat.com:443 to verify RHEL subscription status.  Remote host might be down or blocked by perimeter firewall, or proxy configuration may be incorrect.  $common_output_data | $perf_data \n";
      print_to_outputfile;           				#call subroutine to confirm the output is in the $output_filename used for subsequent script runs
      print $output_message;
      exit $UNKNOWN;
   }
   #
   if ( $rhelsub{Status} eq "Not Subscribed" ) {
      $output_message = "$CHECK_NAME CRITICAL - RHEL subscription is Not Subscribed.  Please add a subscription with subscription-manager  $common_output_data | $perf_data \n";
      print_to_outputfile;           				#call subroutine to confirm the output is in the $output_filename used for subsequent script runs
      print $output_message;
      exit $CRITICAL;
   }
   if ( $datecalc < 0 ) {
      $output_message = "$CHECK_NAME CRITICAL - RHEL subscription expired  $common_output_data | $perf_data \n";
      print_to_outputfile;           				#call subroutine to confirm the output is in the $output_filename used for subsequent script runs
      print $output_message;
      exit $CRITICAL;
   }
   if ( $datecalc < 30 ) {
      $output_message = "$CHECK_NAME WARN - RHEL subscription will be expiring on $rhelsub{Ends}, please renew subscription.  $common_output_data | $perf_data \n";
      print_to_outputfile;           				#call subroutine to confirm the output is in the $output_filename used for subsequent script runs
      print $output_message;
      exit $WARN;
   }
   # should only get here if everything is ok
   if ( $datecalc >= 30 ) {
      $output_message = "$CHECK_NAME OK - RHEL subscription will expire on $rhelsub{Ends}  $common_output_data | $perf_data \n";
      print_to_outputfile;           				#call subroutine to confirm the output is in the $output_filename used for subsequent script runs
      print $output_message;
      exit $OK;
   }
}			#end of subroutine




# ---------------- main body of script -------------------------
get_options;
sanity_checks;
check_for_output_file;
check_internet_access;
get_subscription_status;
print_output;






